# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Wapor_plugins
                                 A QGIS plugin
 plugin to download wapor data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-26
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Hasitha_Jayasekara
        email                : shbbandara@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QComboBox, QLabel
# Import required QGIS modules
from qgis.core import QgsProject, QgsRasterLayer
import os  # This is is needed in the pyqgis console also
import requests
from osgeo import gdal
import matplotlib.pyplot as plt
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .wapor_download_dialog import Wapor_pluginsDialog
import os.path


cubes_request_url = f"https://io.apps.fao.org/gismgr/api/v1/catalog/workspaces/WAPOR_2/cubes?paged=false"
cubes_request_response = requests.get(cubes_request_url)
# cubes_request_response.raise_for_status()
cubeCodeDictionary = {x["code"]: x["caption"]
                      for x in cubes_request_response.json()["response"]}

global levelList
levelList = ["Continental", "National", "Sub-National"]
global basinComboBoxValue
global cubeCode


class Wapor_plugins:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Wapor_plugins_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&WaPOR Data Download')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Wapor_plugins', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/wapor_download/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'WaPOR data download'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&WaPOR Data Download'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = Wapor_pluginsDialog()
            self.dlg.API_push_button.clicked.connect(self.apiRegistration)

            self.dlg.levelComboBox.addItems(levelList)
            self.dlg.levelComboBox.activated.connect(self.levelComboActive)

            self.dlg.basinComboBox.setVisible(False)
            self.dlg.label_river_basin.setVisible(False)

            self.dlg.productComboBox.activated.connect(self.productComboActive)
            self.dlg.next_page_button.clicked.connect(self.nextPage)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

            # workspace = "WAPOR_2"
            # cubecode = "L2_I_A"
            # rasterid = "L2_I_18"

            # tif_request_url = f"https://io.apps.fao.org/gismgr/api/v1/download/{workspace}?requestType=MAPSET_RASTER&cubeCode={cubecode}&rasterId={rasterid}"

            # tif_headers = {"Authorization": f"Bearer {access_token}"}
            # tif_request_response = requests.get(
            #     tif_request_url, headers=tif_headers)
            # tif_request_response.raise_for_status()

            # tif_url = tif_request_response.json()["response"]["downloadUrl"]

            # bounding_box = [80, 7, 81, 6]  # left, top, right, bottom
            # bands = [1]

            # path_absolute = QgsProject.instance().readPath("./")

            # output_filepath = (os.path.join(
            #     path_absolute,  "intercenjmptionex.tif"))

            # translate_options = gdal.TranslateOptions(
            #     projWin=bounding_box, bandList=bands)
            # ds = gdal.Translate(
            #     output_filepath, f"/vsicurl/{tif_url}", options=translate_options)

            # # Load the raster layer
            # layer_name = "Test Layer"  # You can choose a name for the layer
            # raster_layer = QgsRasterLayer(output_filepath, layer_name)

            # # Check if the raster layer was loaded successfully
            # if not raster_layer.isValid():
            #     print("Error: Unable to load the raster layer")
            # else:
            #     # Add the raster layer to the map canvas
            #     QgsProject.instance().addMapLayer(raster_layer)

            #     map_canvas = self.iface.mapCanvas()

            #     # Refresh the map canvas to display the newly added layer
            #     map_canvas.refresh()

            #     map_canvas.setExtent(raster_layer.extent())

            #     # Optionally, zoom to the extent of the raster layer
            #     map_canvas.zoomToFullExtent()

            # # Print a message indicating that the raster file was imported
            # print("Raster file imported successfully!")

    def apiRegistration(self):
        # api_token = str(self.dlg.API_value_lineEdit.text())
        api_token = "5c71fe3bcb024cf98c2bd4a2cd9e32b7955cbee25cd45ced28966a40b25a7eee7e6b6b5cd0ed5711"

        authorization_request_url = "https://io.apps.fao.org/gismgr/api/v1/iam/sign-in"
        authorization_headers = {"X-GISMGR-API-KEY": api_token}
        authorization_request_response = requests.post(
            authorization_request_url, headers=authorization_headers)
        authorization_request_response.raise_for_status()

        global access_token
        access_token = authorization_request_response.json()[
            "response"]["accessToken"]

        print("access_token loaded")

        # to next tab
        current_index = self.dlg.tabWidget.currentIndex()
        next_index = (current_index + 1) % self.dlg.tabWidget.count()
        self.dlg.tabWidget.setCurrentIndex(next_index)

    def levelComboActive(self):

        self.dlg.tempoComboBox.clear()
        self.dlg.productComboBox.clear()

        global productLevel
        global productLevelList
        productLevelList = []
        global productLevelDictionary
        productLevelDictionary = {}
        global tempoList
        tempoList = []

        levelComboBoxValue = str(self.dlg.levelComboBox.currentText())
        if levelComboBoxValue == "Continental":
            productLevel = "L1"

            tempoList = ["Anual", "Monthly", "Decadal", "Daily", "Long Term"]

        if levelComboBoxValue == "National":
            productLevel = "L2"

            tempoList = ["Anual", "Monthly",
                         "Decadal", "Long Term", "Seasonal"]

        if levelComboBoxValue == "Sub-National":
            productLevel = "L3"

            tempoList = ["Anual", "Monthly",
                         "Decadal", "Long Term", "Seasonal"]

            self.dlg.basinComboBox.setVisible(True)
            self.dlg.label_river_basin.setVisible(True)

        temp_lvl_tuple = ()
        for key, value in cubeCodeDictionary.items():
            if key.split('_')[0] == productLevel:
                temp_lvl_tuple += (key, value)

            if temp_lvl_tuple:  # Check if temp_lvl_tuple is not empty
                productLevelList.append(temp_lvl_tuple)
            temp_lvl_tuple = ()
        productLevelDictionary = dict(productLevelList)

        self.dlg.tempoComboBox.addItems(tempoList)
        self.dlg.tempoComboBox.activated.connect(self.tempoComboActive)

    def tempoComboActive(self):

        self.dlg.productComboBox.clear()
        self.dlg.basinComboBox.clear()
        global productTempoList
        productTempoList = []
        global productBasinList
        productBasinList = []
        global productBasinDictionary
        productBasinDictionary = {}
        global productTempoDictionary
        productTempoDictionary = []

        tempoComboBoxValue = str(self.dlg.tempoComboBox.currentText())

        if tempoComboBoxValue == "Anual":
            productTemporalRes = "A"

        if tempoComboBoxValue == "Monthly":
            productTemporalRes = "M"

        if tempoComboBoxValue == "Decadal":
            productTemporalRes = "D"

        if tempoComboBoxValue == "Daily":
            productTemporalRes = "E"

        if tempoComboBoxValue == "Long Term":
            productTemporalRes = "LT"

        if tempoComboBoxValue == "Seasonal":
            productTemporalRes = "S"

        temp_temporal_tuple = ()
        for key, value in productLevelDictionary.items():
            if key.split('_')[-1] == productTemporalRes:
                temp_temporal_tuple += (key, value)

            if temp_temporal_tuple:  # Check if temp_temporal_tuple is not empty
                productTempoList.append(temp_temporal_tuple)
            temp_temporal_tuple = ()

        productTempoDictionary = dict(productTempoList)

        if productLevel != "L3":
            self.dlg.productComboBox.addItems(productTempoDictionary.values())

        temp_basin_tuple = ()

        if productLevel == "L3":
            for key, value in productTempoDictionary.items():
                new_key = key
                temp_basin_tuple += (new_key, value)

                if temp_basin_tuple:
                    productBasinList.append(temp_basin_tuple)
                temp_basin_tuple = ()

            productBasinDictionary = dict(productBasinList)

            unique_items = list(set([value.split('(')[1].split(
                '-')[0] for value in productBasinDictionary.values()]))
            self.dlg.basinComboBox.addItems(unique_items)

            self.dlg.basinComboBox.activated.connect(self.basinComboActive)

    def basinComboActive(self):
        self.dlg.productComboBox.clear()
        global basinComboBoxValue
        basinComboBoxValue = str(self.dlg.basinComboBox.currentText())

        global temp_product_tuple
        temp_product_tuple = ()
        productList = []
        productDictionary = {}

        global basinKey

        for key, value in productBasinDictionary.items():
            if basinComboBoxValue in value:
                basinKey = key

        for key, value in productTempoDictionary.items():
            if key.split('_')[1] == basinKey.split('_')[1]:
                temp_product_tuple += (key, value)

            if temp_product_tuple:
                productList.append(temp_product_tuple)
            temp_product_tuple = ()

        productDictionary = dict(productList)

        self.dlg.productComboBox.addItems(value.split('(')[0] for value in
                                          productDictionary.values())

    def productComboActive(self):
        if self.dlg.productComboBox.currentIndex() != -1:
            self.dlg.next_page_button.setEnabled(True)
            productValue = str(self.dlg.productComboBox.currentText())

            for key, value in productTempoDictionary.items():
                if productLevel == "L3":
                    if productValue in value:
                        if basinComboBoxValue in value:
                            cubeCode = key
                            print("Selected Key:", cubeCode)

                else:
                    if productValue in value:
                        cubeCode = key
                        print("Selected Key:", cubeCode)

    def nextPage(self):
        current_index = self.dlg.tabWidget.currentIndex()
        next_index = (current_index + 1) % self.dlg.tabWidget.count()
        self.dlg.tabWidget.setCurrentIndex(next_index)
